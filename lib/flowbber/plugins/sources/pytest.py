# -*- coding: utf-8 -*-
#
# Copyright (C) 2017-2018 KuraLabs S.R.L
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

"""

Pytest
======

This source parses the JUnit like results XML file generated by pytest_.

.. _pytest: https://docs.pytest.org/


**Data collected:**

.. code-block:: json

    {
        "errors": 0,
        "failures": 2,
        "skips": 0,
        "tests": 4,
        "passed": 6,
        "time": 0.047,
        "suites": {
            "<suite_name>": {
                "errors": 0,
                "failures": 2,
                "skips": 0,
                "tests": 4,
                "time": 0.047,
                "cases": {
                    "<classname>.<name>": {
                        "status": "<PASS|FAIL|ERROR|SKIP>",
                        "file": "test/test_file.py",
                        "line": 19,
                        "classname": "test.test_file",
                        "name": "test_function",
                        "time": 0.0012459754943847656,
                        "properties": [
                            {"<propname1>": "<propvalue1>"},
                            {"<propname2>": "<propvalue2>"}
                        ]
                    }
                }
            }
        }
    }

.. warning::

   Most of the time the ``<suite_name>`` will be set to ``pytest``, but
   do not hardwire your code to that value. It can be changed by changing your
   ``pytest.ini`` file:

   .. code-block: ini

      [pytest]
      junit_suite_name = suite_name

In addition to the previous data structure, if status is ``FAIL``, ``ERROR``
or ``SKIP`` an additional key ``failure``, ``error`` or  ``skipped`` will be
available with information of the problem:

.. code-block:: python3

    {
        # ...
        'error': {
            'code': (
                '@pytest.fixture\\n'
                '    def dofail():\\n'
                '>       raise RuntimeError()\\n'
                'E       RuntimeError\\n\\nconftest.py:14: RuntimeError'
            ),
            'message': 'test setup failure',
        }
    }

The information object always have a ``message`` and a ``code`` key describing
what the issue is and where it happened.


**Dependencies:**

.. code-block:: sh

    pip3 install flowbber[pytest]

**Usage:**

.. code-block:: toml

    [[sources]]
    type = "pytest"
    id = "..."

        [sources.config]
        xmlpath = "tests.xml"

.. code-block:: json

    {
        "sources": [
            {
                "type": "pytest",
                "id": "...",
                "config": {
                    "xmlpath": "tests.xml"
                }
            }
        ]
    }

xmlpath
-------

Path to the JUnit like XML results ``tests.xml`` file to be parsed.

- **Default**: ``N/A``
- **Optional**: ``False``
- **Schema**:

  .. code-block:: python3

     {
         'type': 'string',
         'empty': False,
     }

- **Secret**: ``False``

"""  # noqa

from pathlib import Path
from xml.etree import ElementTree
from collections import OrderedDict

from flowbber.components import Source


def trycast(value):
    """
    Try to cast a string attribute from an XML tag to an integer, then to a
    float. If both fails, return the original string.
    """
    for cast in (int, float):
        try:
            return cast(value)
        except ValueError:
            continue
    return value


class PytestSource(Source):

    def declare_config(self, config):
        config.add_option(
            'xmlpath',
            schema={
                'type': 'string',
                'empty': False,
            },
        )

    def collect(self):
        # Check if file exists
        infile = Path(self.config.xmlpath.value)
        if not infile.is_file():
            raise FileNotFoundError(
                'No such file {}'.format(infile)
            )

        testsuites = OrderedDict()

        tree = ElementTree.parse(str(infile))
        root = tree.getroot()
        if root.tag == 'testsuites':
            # Starting on pytest 4.6.7 adds a <testsuites> root element
            # We can get the first child and keep on.
            root = next(iter(root))

        assert root.tag == 'testsuite', 'Malformed XML root element'

        # Create top level suite object
        testsuite = {
            key: cast(root.attrib[key])
            for key, cast in [
                ('errors', int),
                ('failures', int),
                ('tests', int),
                ('time', float),
            ]
        }

        # skips was changed to skipped on newer pytest, support both options
        testsuite['skips'] = int(
            root.attrib.get('skipped', root.attrib.get('skips'))
        )

        testcases = OrderedDict()
        testsuite['cases'] = testcases
        testsuite['passed'] = 0

        testsuites[root.attrib['name']] = testsuite

        # Add test cases
        for child in root:
            assert child.tag == 'testcase', 'Malformed XML child element'

            # Form an unique name base on classname and testcase name
            tckey = '{}.{}'.format(
                child.attrib['classname'],
                child.attrib['name']
            )
            # Pytest creates duplicates of a test case if there is an error and
            # a failure. It does so in order to be compliant with JUnit schema
            # See https://github.com/pytest-dev/pytest/issues/2228
            testcase = testcases.get(tckey)
            if testcase is None:
                testcase = {
                    key: cast(child.attrib[key])
                    for key, cast in [
                        ('file', str),
                        ('line', int),
                        ('classname', str),
                        ('name', str),
                        ('time', float),
                    ]
                }
                properties = []
                testcase['properties'] = properties
                testcases[tckey] = testcase

            # Add properties
            subchild = child.find('properties')
            if subchild is not None:

                for subchild in child.find('properties'):
                    assert subchild.tag == 'property', \
                        'Malformed XML subchild element'

                    properties.append({
                        subchild.attrib['name']: trycast(
                            subchild.attrib['value']
                        )
                    })

            # Add status
            for status, childkey in [
                ('FAIL', 'failure'),
                ('ERROR', 'error'),
                ('SKIP', 'skipped'),
                ('PASS', None),
            ]:
                testcase['status'] = status

                if childkey is None:
                    break

                subchild = child.find(childkey)
                if subchild is not None:
                    testcase[childkey] = {
                        'message': subchild.attrib['message'],
                        'code': subchild.text,
                    }
                    break

            if testcase['status'] == 'PASS':
                testsuite['passed'] += 1

        result = {
            key: sum(suite[key] for suite in testsuites.values())
            for key in [
                'errors', 'failures', 'skips', 'tests', 'time', 'passed'
            ]
        }
        result['suites'] = testsuites

        return result


__all__ = ['PytestSource']
